<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=640">

    <link rel="stylesheet" href="stylesheets/core.css" media="screen">
    <link rel="stylesheet" href="stylesheets/mobile.css" media="handheld, only screen and (max-device-width:640px)">
    <link rel="stylesheet" href="stylesheets/github-light.css">

    <script type="text/javascript" src="javascripts/modernizr.js"></script>
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script type="text/javascript" src="javascripts/headsmart.min.js"></script>
    <script type="text/javascript">
      $(document).ready(function () {
        $('#main_content').headsmart()
      })
    </script>
    <title>Ledcube by stefanp312</title>
  </head>

  <body>
    <a id="forkme_banner" href="https://github.com/stefanp312/LEDcube">View on GitHub</a>
    <div class="shell">

      <header>
        <span class="ribbon-outer">
          <span class="ribbon-inner">
            <h1>Ledcube</h1>
            <h2>Ever wanted to build a cube of individually addressable LEDs? Well I did. Here&#39;s a tutorial to teach you how.</h2>
          </span>
          <span class="left-tail"></span>
          <span class="right-tail"></span>
        </span>
      </header>

      <section id="downloads">
        <span class="inner">
          <a href="https://github.com/stefanp312/LEDcube/zipball/master" class="zip"><em>download</em> .ZIP</a><a href="https://github.com/stefanp312/LEDcube/tarball/master" class="tgz"><em>download</em> .TGZ</a>
        </span>
      </section>


      <span class="banner-fix"></span>


      <section id="main_content">
        <h1>
<a id="ledcube" class="anchor" href="#ledcube" aria-hidden="true"><span class="octicon octicon-link"></span></a>LEDcube</h1>

<p>Ever wanted to build a cube of individually addressable LEDs? Well I did. Here's the code that controls the cubes as well as documentation explaining how and why we built things certain ways.</p>

<p>Note that this project was tailored to fit the specifications for a group project at school. We needed to include: timers, a custom millis function, an Arduino, interrupts, and complex hardware.</p>

<p><img src="https://github.com/stefanp312/LEDcube/blob/master/imagesForReadMe/Collage.jpg" alt=""></p>

<h2>
<a id="prototype" class="anchor" href="#prototype" aria-hidden="true"><span class="octicon octicon-link"></span></a>Prototype</h2>

<p>An iteractive design process was used in order to complete this project. A smaller prototype cube was first created so that we could familarize ourselves with the assembly process, shift registers and so that software for the cube could be developed concurently to speed up the over all project completion time.</p>

<blockquote>
<p>Baby Chirstmas Cube
<img src="https://github.com/stefanp312/LEDcube/blob/master/imagesForReadMe/BabyCube.JPG" alt=""></p>
</blockquote>

<h2>
<a id="the-hardware" class="anchor" href="#the-hardware" aria-hidden="true"><span class="octicon octicon-link"></span></a>The hardware.</h2>

<h3>
<a id="cliff-notes" class="anchor" href="#cliff-notes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cliff notes:</h3>

<p><em>Part list</em> (quantities bolded): </p>

<ol>
<li>8-bit Shift Registers <a href="https://www.sparkfun.com/products/733">(Part #: 74HC595)</a>  <strong>x 2</strong>
</li>
<li>Red Diffused LEDs (We bought 70 in case any were broken) <strong>x 64</strong>
</li>
<li>Wire/Jumper Cable *<em>LOTS</em>
</li>
<li>Arduino</li>
<li>Soldering Iron / Solder</li>
<li>Breadboard</li>
<li>Push Button </li>
<li>Scrap Wood (One square foot 1/4 inch thick)</li>
</ol>

<p><em>Tips:</em></p>

<ul>
<li><p>Cube Size: 4x4x4 (Expect around 10 hours of soldering time)</p></li>
<li><p>Use scrap wood to make a template for soldering.</p></li>
<li><p>Use diffused LEDs so the cube seems brighter.</p></li>
<li><p>Find a shift register that has built-in resistors.</p></li>
</ul>

<h3>
<a id="the-full-story" class="anchor" href="#the-full-story" aria-hidden="true"><span class="octicon octicon-link"></span></a>The full story</h3>

<p>The first and one of the most important decisions you will make when building an LED cube is the size. My group initially thought that bigger is always better but soon realized the number of LEDs and the amount of time required to solder the cube increases dramatically. Since we were on a limited time budget due to our course load at school and the project deadline we decided to build a 4x4x4 cube.</p>

<p>The first problem we had to tackle was how do we address all these LEDs individually. The Arduino Uno that was being used did not have enough output pins to directly control the number of LEDs we wanted to use. We began researching on the internet and saw that larger cubes connected the LEDs in a specific way. A single layer of the cube would share a ground connection (cathode) and each column would share a voltage pin. This allows the software to address any LED on the cube by using toggling specific voltage pins and providing a ground connection to certain layers. This decreases the number of output pins to 20 (16 anodes and 4 cathodes).</p>

<p><strong>Top View</strong></p>

<p>x---x---x---x</p>

<p>x---x---x---x</p>

<p>x---x---x---x</p>

<p>x---x---x---x</p>

<blockquote>
<p>Each "x" represents a column of LEDs which would share a common voltage source (anode).
All of these LEDs would share a common ground (cathode).</p>
</blockquote>

<p>Going from 64 output pins to 20 is a huge upgrade. However, we could do better. Using two 8-bit shift registers we were able to decrease that number to just 3. We chained the shift registers so that using a clock, data and latch pin we were alble to control 16 outputs.</p>

<blockquote>
<p>Shift registers are a type of integrated circuit (IC) that are used to transform serial data into parallel data. They can be thought of as a storage tank that uses one main pipeline (data pin) to let 1 bit of data per clock cycle (clock pin). When the tank is full (latch pin), the tank releases all the data down multiple pipelines (output pins). </p>
</blockquote>

<p>There was a trade off to using shift registers as they increased software complexity and also added a very small insignificant latency to the update time on the cube. There is also additional wiring necessary to connect the two shift registers together.</p>

<blockquote>
<p>It would now take a minimum of 16 processor cycles to update the cube. However, the Arduino Uno runs at 16 Mhz which means that a cycle would last 0.0625 milli-seconds and the total delay added would be 1 milli-second.
This is not perceivable to a human so the coolness factor of using shift registers won out.</p>
</blockquote>

<p>A piece of scrap wood was acquired from the student machine shop so that a template for the cube could be constructed. The length of the LEDs legs were measured so that the spacing between the holes on the template could be determined. There was a safety factor of 2 mm on the LED leg measurements so that soldering could be made easier. LEDs were put into the template holes head first and alligned to fit the guidelines drawn. The template helped ensure that the layers made for the cube were as orthogonal as possible.</p>

<blockquote>
<p>8 hours later...
<img src="https://github.com/stefanp312/LEDcube/blob/master/imagesForReadMe/CreatingLayers.jpg" alt=""></p>

<p>2 hours later!!!
<img src="https://github.com/stefanp312/LEDcube/blob/master/imagesForReadMe/FinalProduct.jpg" alt=""></p>
</blockquote>

<p>A push button was installed on a bread board to be used as an interupt source so that the pattern displayed on the cube could be changed. The reason we chose to use diffused LEDs was that they provided a uniform light from any angle. This would make the cube seem brighter since every LED is seen from a different angle and multiple locations. We chose red because we thought it would look cool in the dark.</p>

<p>Every column of LEDs also has a resistor attached to it so that none of the LEDs burn out. I would recomend finding a shift register with built-in resistors to make the wiring of the cube look nicer. Due to the added complexity of adding another shift register to control which layer would recieve a ground connection, it was decided that we would just use 4 seperate pins to control it.</p>

<h2>
<a id="software-tingz" class="anchor" href="#software-tingz" aria-hidden="true"><span class="octicon octicon-link"></span></a>Software Tingz</h2>

<h3>
<a id="cliff-notes-1" class="anchor" href="#cliff-notes-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cliff Notes.</h3>

<ul>
<li><p>A 3D array was mapped to the LEDs on the physical cube.</p></li>
<li><p>Uses persitence of vision to light up the cube layer by layer and look normal.</p></li>
<li><p>Patterns were created as various functions which manipulated a 3D matrix.</p></li>
<li><p>MVC Design.</p></li>
</ul>

<h3>
<a id="the-full-story-1" class="anchor" href="#the-full-story-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>The full story</h3>

<p>There are a few functions which seem random and unnecessary but were project requirements. The design I used is similar to the MVC used in iOS. The model is the 3D array which contains the data to be displayed. The view is the physical cube which acts as a sort of display. The controller would then be the update function which is responsible for making sure the cube looks like what the datasources describes.</p>

<p><strong>Mapping The Cube</strong></p>

<p>In order to control the LED cube I needed a way to model the cube in code and then update the cube with the data from the model. I used a boolean array with 3 dimensions that represented the X,Y,Z coordinates of an LED on the cube. Now when creating patterns for the cube, only the datasource needed to be modified thus simplifying the pattern making process.</p>

<p>I could only update the cube one layer at a time due to the way the LEDs were wired however this problem solved by using the persistence of human vision. If we updated each layer sucessively and fast enough it would appear to an observer that the entire cube was illuminated at the same time. The only time that this illusion could break down is if the update rate of the cube is decreased.</p>

<p>Thus, I only needed to be able to address 16 LEDs at a time using the shift registers. This meant that I would need to shift out 2 bytes of data when updating one layer of the cube. These bytes of data were created by iterating of the datasource and adding values to them from an array made when the Arduino first starts up. Each LED on a face is mapped to a power of two, thus when you add these values together you can illuminate multiple LEDs. The way it works is the first byte gets sent into the first register initially, then when the next bye is shifted out it takes the place of the first byte and pushes it into the second register.</p>

<p><strong>Update Function</strong></p>

<div class="highlight highlight-c"><pre><span class="pl-c">//This is the main function that ensures that the LED cube is kept updated with the datasource</span>
<span class="pl-k">void</span> <span class="pl-en">updateCubeWithDataSource</span>() {
  <span class="pl-k">for</span> (<span class="pl-k">int</span> k = <span class="pl-c1">0</span>; k &lt; CUBE_SIZE; k++) {
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; CUBE_SIZE; i++) {
      <span class="pl-k">for</span> (<span class="pl-k">int</span> j = <span class="pl-c1">0</span>; j &lt; CUBE_SIZE; j++) {
        <span class="pl-c">//This loop will go through every value of the dataSource</span>
        <span class="pl-c">//Check if the value needs to be written to</span>
        <span class="pl-k">if</span> (dataSource[i][j][k] == <span class="pl-c1">1</span>) {
          <span class="pl-c">//If it needs to be written to the cube add it to the data</span>
          <span class="pl-c">//We can add it to the data because each LED is mapped to a power of 2 and we are essentially doing an 'or' operation on what to light up</span>
          <span class="pl-c">//The check to j is to decide which byte to write to</span>
          <span class="pl-k">if</span> (j &lt; <span class="pl-c1">2</span>) {
            data1 = data1 + ledAddress[i][j];
          }
          <span class="pl-k">else</span> {
            data2 = data2 + ledAddress[i][j];
          }
        }
      }
    }
    <span class="pl-c">//At this point we have gone through one entire layer and can write that layer to the cube</span>
    <span class="pl-c1">writeLayerToCube</span>(k);
  }
}</pre></div>

<p><strong>How To Shift</strong></p>

<div class="highlight highlight-C"><pre><span class="pl-c">//This function write data to a chosen layer of the cube</span>
<span class="pl-k">void</span> <span class="pl-en">writeLayerToCube</span>(<span class="pl-k">int</span> layer) {
  <span class="pl-c">//First we need to drop the latch and clock low</span>
  <span class="pl-c">//Dropping the latch low makes the shift register take in data</span>
  <span class="pl-c">//Putting the clock low makes sure that no data is accidentally written to the register.</span>
  <span class="pl-c1">digitalWrite</span>(latchPin, <span class="pl-c1">0</span>);
  <span class="pl-c1">digitalWrite</span>(clockPin, <span class="pl-c1">0</span>);

  <span class="pl-c">//Write a face of data to the cube</span>
  <span class="pl-c1">shiftOut</span>(dataPin, clockPin, MSBFIRST, data2);
  <span class="pl-c1">shiftOut</span>(dataPin, clockPin, MSBFIRST, data1);
  <span class="pl-c">//Close the latch so it can update</span>
  <span class="pl-c1">digitalWrite</span>(latchPin, <span class="pl-c1">1</span>);

  <span class="pl-c">//Next we need to select the correct layer by picking the right ground</span>
  <span class="pl-c">//Match the layer value with the correct pin stored in the layerAddress array</span>
  <span class="pl-k">if</span> (data1 != <span class="pl-c1">0</span> || data2 != <span class="pl-c1">0</span>) {
    <span class="pl-c1">raiseAllGrounds</span>();
    <span class="pl-c1">digitalWrite</span>(layerAddress[layer], <span class="pl-c1">0</span>);
  }
  <span class="pl-c">//Clear the data</span>
  data1 = <span class="pl-c1">0</span>;
  data2 = <span class="pl-c1">0</span>;
}</pre></div>

<p><strong>Creating Patterns</strong></p>

<p>Due to the design of the software designing patterns is quite simple. There exists only the restriction that each state of the animation has the same duration. However different animations can have different durations so it would be technically possible to chain multiple animation functions together in order to have different state durations.</p>

<p>Making an animation consists of calling the <em>stateChange</em> function with the duration of each animation frame. Then you need a conditional statement with the global variable <em>counter</em>. Inside that statement you modify the datasource as necessary. The <em>stateChange</em> function will automatically increment the counter variable so make sure that in the last state of the animation <em>counter</em> is set to 0.</p>

<div class="highlight highlight-C"><pre><span class="pl-k">void</span> <span class="pl-en">stateChange</span>(<span class="pl-k">int</span> timeInMilliSeconds) {
  <span class="pl-k">if</span> (<span class="pl-c1">Millis</span>() &gt;= timeInMilliSeconds) {
    <span class="pl-c">//increment the state variable</span>
    counter++;
    millis_timer = <span class="pl-c1">0</span>;
  }
}

<span class="pl-k">void</span> <span class="pl-en">BlinkyRand</span>() {
  <span class="pl-c1">stateChange</span>(<span class="pl-c1">350</span>);
  <span class="pl-k">if</span> (counter == <span class="pl-c1">0</span>) {
    <span class="pl-c1">writeValueToEntireDataSource</span>(<span class="pl-c1">0</span>);
    <span class="pl-k">int</span> x = <span class="pl-c1">random</span>(<span class="pl-c1">4</span>);
    <span class="pl-k">int</span> y = <span class="pl-c1">random</span>(<span class="pl-c1">4</span>);
    <span class="pl-k">int</span> z = <span class="pl-c1">random</span>(<span class="pl-c1">4</span>);
    dataSource[x][y][z] = <span class="pl-c1">1</span>;
  }
  <span class="pl-k">if</span> (counter == <span class="pl-c1">1</span>) {
  }
  <span class="pl-k">if</span> (counter == <span class="pl-c1">2</span>) {
    counter = <span class="pl-c1">0</span>;
  }
}</pre></div>

<p><strong>Custom Millis</strong></p>

<p>The built-in millis function was rewritten by tracking the number of overflow interrupted that occur on hardware timer 2 of the Arduino. A timer prescaler value of 64 was used as it brought the duration closest to 1 millisecond. There was some roundoff error which was ignored since no more than a second is being timed before reseting the timer register. In one second, the maximum possible error is 24 milliseconds which is negligible in this use case.</p>
      </section>

      <footer>
        <span class="ribbon-outer">
          <span class="ribbon-inner">
            <p>this project by <a href="https://github.com/stefanp312">stefanp312</a> can be found on <a href="https://github.com/stefanp312/LEDcube">GitHub</a></p>
          </span>
          <span class="left-tail"></span>
          <span class="right-tail"></span>
        </span>
        <p>Generated with <a href="https://pages.github.com">GitHub Pages</a> using Merlot</p>
        <span class="octocat"></span>
      </footer>

    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-59917732-3");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
